<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Test - RHCSA Practice Labs</title>
    <link href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { margin: 0 0 20px 0; font-size: 1.5rem; }
        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        .status.connected { background: #064e3b; border: 1px solid #10b981; }
        .status.disconnected { background: #7f1d1d; border: 1px solid #ef4444; }
        .status.connecting { background: #78350f; border: 1px solid #f59e0b; }
        .status.provisioning { background: #1e3a5f; border: 1px solid #3b82f6; }
        .session-info {
            background: #262626;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .session-info h3 { margin: 0 0 10px 0; font-size: 1rem; }
        .session-detail { margin: 5px 0; font-size: 0.85rem; color: #a1a1aa; }
        .session-detail span { color: #fff; }
        .buttons { display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap; }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            font-weight: 500;
        }
        button.primary { background: #ef4444; color: #fff; }
        button.primary:hover { background: #dc2626; }
        button.secondary { background: #3f3f46; color: #fff; }
        button.secondary:hover { background: #52525b; }
        button.success { background: #059669; color: #fff; }
        button.success:hover { background: #047857; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #terminal-container {
            background: #000;
            border-radius: 8px;
            padding: 10px;
            height: 500px;
        }
        #terminal { height: 100%; }
        .tabs { display: flex; gap: 5px; margin-bottom: 10px; }
        .tab {
            padding: 8px 16px;
            background: #262626;
            border: none;
            border-radius: 4px 4px 0 0;
            color: #a1a1aa;
            cursor: pointer;
            font-size: 0.85rem;
        }
        .tab.active { background: #000; color: #fff; }
        .tab:hover:not(.active) { background: #3f3f46; }
        .hidden { display: none; }
        .loading { display: inline-block; animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <h1>üíª RHCSA Practice Terminal</h1>
        
        <div id="status" class="status disconnected">
            ‚óè No active session
        </div>

        <div class="session-info">
            <h3>Session</h3>
            <div id="session-details">
                <p class="session-detail">No session active. Create one to start practicing.</p>
            </div>
            <div class="buttons">
                <button id="create-btn" class="success" onclick="createSession()">
                    Create Session
                </button>
                <button id="provision-btn" class="primary hidden" onclick="provisionSession()">
                    Provision VMs
                </button>
                <button id="destroy-btn" class="secondary hidden" onclick="destroySession()">
                    Destroy Session
                </button>
            </div>
        </div>

        <div id="terminal-section" class="hidden">
            <div class="tabs">
                <button class="tab active" id="tab-node1" onclick="connectToNode('node1')">
                    rhcsa1 (node1)
                </button>
                <button class="tab" id="tab-node2" onclick="connectToNode('node2')">
                    rhcsa2 (node2)
                </button>
            </div>
            <div id="terminal-container">
                <div id="terminal"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.8.0/lib/addon-fit.min.js"></script>
    <script>
        let socket = null;
        let terminal = null;
        let fitAddon = null;
        let currentSession = null;
        let currentNode = 'node1';

        // Initialize terminal
        function initTerminal() {
            if (terminal) return;
            
            terminal = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: '"Cascadia Code", "Fira Code", Menlo, Monaco, monospace',
                theme: {
                    background: '#000000',
                    foreground: '#ffffff',
                    cursor: '#ffffff',
                    selection: 'rgba(255, 255, 255, 0.3)',
                }
            });

            fitAddon = new FitAddon.FitAddon();
            terminal.loadAddon(fitAddon);
            terminal.open(document.getElementById('terminal'));
            fitAddon.fit();

            // Handle input
            terminal.onData(data => {
                if (socket && socket.connected) {
                    socket.emit('terminal_input', { data });
                }
            });
        }

        function updateStatus(status, message) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${status}`;
            statusEl.innerHTML = `‚óè ${message}`;
        }

        function updateSessionUI(session) {
            currentSession = session;
            const details = document.getElementById('session-details');
            const createBtn = document.getElementById('create-btn');
            const provisionBtn = document.getElementById('provision-btn');
            const destroyBtn = document.getElementById('destroy-btn');
            const terminalSection = document.getElementById('terminal-section');

            if (!session) {
                details.innerHTML = '<p class="session-detail">No session active. Create one to start practicing.</p>';
                createBtn.classList.remove('hidden');
                provisionBtn.classList.add('hidden');
                destroyBtn.classList.add('hidden');
                terminalSection.classList.add('hidden');
                updateStatus('disconnected', 'No active session');
                return;
            }

            const timeRemaining = Math.max(0, Math.floor(session.time_remaining_seconds / 60));
            details.innerHTML = `
                <p class="session-detail">ID: <span>${session.session_id}</span></p>
                <p class="session-detail">State: <span>${session.state}</span></p>
                <p class="session-detail">Time remaining: <span>${timeRemaining} minutes</span></p>
                ${session.node1_ip ? `<p class="session-detail">Node1 IP: <span>${session.node1_ip}</span></p>` : ''}
                ${session.node2_ip ? `<p class="session-detail">Node2 IP: <span>${session.node2_ip}</span></p>` : ''}
                ${session.error ? `<p class="session-detail" style="color:#ef4444">Error: <span>${session.error}</span></p>` : ''}
            `;

            createBtn.classList.add('hidden');
            
            if (session.state === 'pending') {
                provisionBtn.classList.remove('hidden');
                provisionBtn.disabled = false;
                destroyBtn.classList.remove('hidden');
                terminalSection.classList.add('hidden');
                updateStatus('disconnected', 'Session created - click Provision to start VMs');
            } else if (session.state === 'provisioning') {
                provisionBtn.classList.remove('hidden');
                provisionBtn.disabled = true;
                provisionBtn.innerHTML = '<span class="loading">‚ü≥</span> Provisioning...';
                destroyBtn.classList.add('hidden');
                terminalSection.classList.add('hidden');
                updateStatus('provisioning', 'Provisioning VMs... (this takes 2-5 minutes)');
            } else if (session.state === 'ready' || session.state === 'active') {
                provisionBtn.classList.add('hidden');
                destroyBtn.classList.remove('hidden');
                terminalSection.classList.remove('hidden');
                initTerminal();
                updateStatus('connected', `Session ready - connected to ${currentNode}`);
            } else if (session.state === 'failed') {
                provisionBtn.classList.add('hidden');
                destroyBtn.classList.remove('hidden');
                terminalSection.classList.add('hidden');
                updateStatus('disconnected', 'Session failed - destroy and try again');
            } else {
                provisionBtn.classList.add('hidden');
                destroyBtn.classList.add('hidden');
                terminalSection.classList.add('hidden');
                updateStatus('disconnected', `Session ${session.state}`);
            }
        }

        async function checkActiveSession() {
            try {
                const resp = await fetch('/api/sessions/active');
                const session = await resp.json();
                updateSessionUI(session);
                if (session && (session.state === 'ready' || session.state === 'active')) {
                    connectToNode(currentNode);
                }
            } catch (e) {
                console.error('Failed to check session:', e);
            }
        }

        async function createSession() {
            try {
                updateStatus('connecting', 'Creating session...');
                const resp = await fetch('/api/sessions', { method: 'POST' });
                const session = await resp.json();
                if (resp.ok) {
                    updateSessionUI(session);
                } else {
                    alert(session.error || 'Failed to create session');
                    updateStatus('disconnected', 'Failed to create session');
                }
            } catch (e) {
                console.error('Failed to create session:', e);
                alert('Failed to create session');
            }
        }

        async function provisionSession() {
            if (!currentSession) return;
            
            try {
                updateSessionUI({ ...currentSession, state: 'provisioning' });
                const resp = await fetch(`/api/sessions/${currentSession.session_id}/provision`, { method: 'POST' });
                const session = await resp.json();
                if (resp.ok) {
                    updateSessionUI(session);
                    connectToNode(currentNode);
                } else {
                    alert(session.error || 'Failed to provision session');
                    checkActiveSession();
                }
            } catch (e) {
                console.error('Failed to provision session:', e);
                alert('Failed to provision session');
                checkActiveSession();
            }
        }

        async function destroySession() {
            if (!currentSession) return;
            if (!confirm('Destroy this session? All VMs will be terminated.')) return;
            
            try {
                updateStatus('connecting', 'Destroying session...');
                if (socket) {
                    socket.disconnect();
                    socket = null;
                }
                await fetch(`/api/sessions/${currentSession.session_id}`, { method: 'DELETE' });
                currentSession = null;
                updateSessionUI(null);
            } catch (e) {
                console.error('Failed to destroy session:', e);
                alert('Failed to destroy session');
            }
        }

        function connectToNode(node) {
            if (!currentSession || !['ready', 'active'].includes(currentSession.state)) return;

            currentNode = node;
            
            // Update tab UI
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById(`tab-${node}`).classList.add('active');

            // Clear terminal
            if (terminal) {
                terminal.clear();
                terminal.write(`\r\nConnecting to ${node}...\r\n`);
            }

            // Disconnect existing socket
            if (socket) {
                socket.disconnect();
            }

            // Connect to WebSocket
            socket = io('/terminal', {
                transports: ['polling', 'websocket']
            });

            socket.on('connect', () => {
                console.log('Socket connected, starting terminal...');
                socket.emit('start_session_terminal', {
                    session_id: currentSession.session_id,
                    node: node,
                    cols: terminal ? terminal.cols : 80,
                    rows: terminal ? terminal.rows : 24
                });
            });

            socket.on('terminal_ready', (data) => {
                console.log('Terminal ready:', data);
                updateStatus('connected', `Connected to ${data.node} (${data.host})`);
                if (terminal) {
                    terminal.clear();
                    terminal.focus();
                }
            });

            socket.on('terminal_output', (data) => {
                if (terminal) {
                    terminal.write(data.data);
                }
            });

            socket.on('terminal_error', (data) => {
                console.error('Terminal error:', data.error);
                updateStatus('disconnected', `Error: ${data.error}`);
                if (terminal) {
                    terminal.write(`\r\n\x1b[31mError: ${data.error}\x1b[0m\r\n`);
                }
            });

            socket.on('terminal_disconnected', (data) => {
                console.log('Terminal disconnected:', data);
                updateStatus('disconnected', 'Terminal disconnected');
            });

            socket.on('disconnect', () => {
                console.log('Socket disconnected');
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (fitAddon && terminal) {
                fitAddon.fit();
                if (socket && socket.connected) {
                    socket.emit('terminal_resize', {
                        cols: terminal.cols,
                        rows: terminal.rows
                    });
                }
            }
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            checkActiveSession();
        });
    </script>
</body>
</html>
